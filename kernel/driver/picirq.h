#ifndef __KERNEL_DRIVER_PICIRQ_H__
#define __KERNEL_DRIVER_PICIRQ_H__
#include "defs.h"
//
//初始化pic
void pic_init(void);
//使能中断
void pic_enable(uint32_t irq);

//如今绝大多数的PC都拥有两个8259A，这样最多可以接收15个中断源
//8259A的编程是通过向其相应的端口发送一系列的ICW（初始化命令字）完成的。
//总共需要发送四个ICW，它们都分别有自己独特的格式，而且必须按次序发送，并且必须发送到相应的端口，主片的端口号为0x20，从片的端口号为0xA0。
// 8259A的初始化是通过CPU对8259A送4个方式控制字ICW1、ICW2、ICW3、ICW4以及3个操作命令字OCW1、OCW2和OCW3。
//
// 由于8259A只占用两个I/O端口地址，但要写入四个方式控制字和三个操作命令字，
// 因而其各寄存器的读写是I/O地址和特征位及顺序配合完成的：写入方式控制字必须按照ICW1～ICW4的顺序进行。
#define IRQ_OFFSET 32 //0x20 --> 10000

/*
 * 中断:
 * 0 比如定时器发出中断时, 程序咋样找到了:vectores.S中的vector32????也就是咋样找到哪个门描述符?? 
 *  这个是有硬件决定的.也就是说连接8259的中断源是硬件固定了, 时钟就是IR0,也就是请求号为IRQ0, 固定死了, 另外我们的中断号是自己定义的(必须是8的倍数), 中断号有个开始的号码(这里是32), 所以32对应IRQ0, 对应时钟中断
 * 1 CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量, 然后根据得到的中断向量为索引到IDT中找到该向量对应的中断描述符，中断描述符里保存着基地址(vector32), 上面是cpu自动完成的.
 */
#endif
